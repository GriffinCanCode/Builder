module languages.web.typescript.tooling.bundlers.vite;

import languages.web.typescript.tooling.bundlers.base;
import languages.web.typescript.core.config;
import languages.web.typescript.tooling.checker;
import config.schema.schema;
import std.process;
import std.path;
import std.file;
import std.algorithm;
import std.array;
import std.conv;
import std.json;
import std.string;
import utils.files.hash;
import utils.logging.logger;

/// Vite bundler for TypeScript - modern dev server with lightning-fast HMR and optimized production builds
/// Best for: Modern TypeScript projects, React/Vue/Svelte with TypeScript, library development with type safety
class TSViteBundler : TSBundler
{
    TSCompileResult compile(
        const(string[]) sources,
        TSConfig config,
        in Target target,
        in WorkspaceConfig workspace
    )
    {
        TSCompileResult result;
        
        // Check if vite is available
        if (!isAvailable())
        {
            result.error = "vite not found. Install: npm install -g vite";
            return result;
        }
        
        // Type check first if strict mode
        if (config.strict)
        {
            auto checkResult = TypeChecker.check(sources, config, workspace.root);
            if (!checkResult.success)
            {
                result.hadTypeErrors = true;
                result.typeErrors = checkResult.errors;
                Logger.warning("Type check failed, but continuing with vite build");
            }
        }
        
        // Check for existing vite.config.ts/js
        string viteConfig = detectViteConfig(sources);
        if (!viteConfig.empty)
        {
            Logger.debugLog("Detected vite config: " ~ viteConfig);
            return bundleWithConfigFile(viteConfig, workspace, result);
        }
        
        // Generate temporary config for precise control
        return bundleWithGeneratedConfig(sources, config, target, workspace, result);
    }
    
    private TSCompileResult bundleWithConfigFile(
        string configFile,
        in WorkspaceConfig workspace,
        ref TSCompileResult result
    )
    {
        Logger.debugLog("Using Vite config: " ~ configFile);
        
        string[] cmd = ["npx", "vite", "build", "--config", configFile];
        
        string configDir = dirName(absolutePath(configFile));
        auto res = execute(cmd, null, Config.none, size_t.max, configDir);
        
        if (res.status != 0)
        {
            result.error = "vite build failed: " ~ res.output;
            return result;
        }
        
        result.success = true;
        
        // Parse Vite output - default is dist/ directory
        string outputDir = buildPath(configDir, "dist");
        if (exists(outputDir) && isDir(outputDir))
        {
            collectOutputs(outputDir, result);
        }
        else
        {
            // Fallback to workspace output dir
            outputDir = workspace.options.outputDir;
            if (exists(outputDir) && isDir(outputDir))
            {
                collectOutputs(outputDir, result);
            }
        }
        
        if (result.outputs.empty)
        {
            result.error = "No outputs generated by Vite";
            return result;
        }
        
        result.outputHash = FastHash.hashFiles(result.outputs);
        
        return result;
    }
    
    private TSCompileResult bundleWithGeneratedConfig(
        const(string[]) sources,
        TSConfig config,
        in Target target,
        in WorkspaceConfig workspace,
        ref TSCompileResult result
    )
    {
        string entry = config.entry.empty ? sources[0] : config.entry;
        string outputDir = config.outDir.empty ? workspace.options.outputDir : config.outDir;
        mkdirRecurse(outputDir);
        
        string outputFile = target.name.split(":")[$ - 1] ~ ".js";
        
        // Detect framework for preset optimization
        Framework framework = detectFramework(sources);
        
        // Generate temporary Vite config
        string viteConfig = generateViteConfig(
            entry,
            outputDir,
            outputFile,
            config,
            framework,
            target
        );
        
        // Write temporary config in project root (where package.json is)
        string projectDir = dirName(absolutePath(entry));
        string packageJsonPath = "";
        string searchDir = projectDir;
        while (searchDir != "/" && searchDir.length > 1)
        {
            string pkgPath = buildPath(searchDir, "package.json");
            if (exists(pkgPath))
            {
                packageJsonPath = pkgPath;
                projectDir = searchDir;
                break;
            }
            searchDir = dirName(searchDir);
        }
        
        string tempConfig = buildPath(projectDir, "vite.config.temp.ts");
        std.file.write(tempConfig, viteConfig);
        
        scope(exit)
        {
            if (exists(tempConfig))
                remove(tempConfig);
        }
        
        Logger.debugLog("Generated Vite config: " ~ tempConfig);
        
        // Run Vite build
        string[] cmd = ["npx", "vite", "build", "--config", tempConfig];
        
        auto res = execute(cmd, null, Config.none, size_t.max, projectDir);
        
        if (res.status != 0)
        {
            result.error = "vite build failed: " ~ res.output;
            return result;
        }
        
        Logger.debugLog("Vite build completed successfully");
        
        result.success = true;
        
        // Collect outputs from output directory
        collectOutputs(outputDir, result);
        
        if (result.outputs.empty)
        {
            // Fallback: assume primary output
            string primaryOutput = buildPath(outputDir, outputFile);
            if (exists(primaryOutput))
            {
                result.outputs = [primaryOutput];
            }
        }
        
        result.outputHash = FastHash.hashFiles(result.outputs);
        
        return result;
    }
    
    /// Detect Vite config in project
    private string detectViteConfig(const(string[]) sources)
    {
        if (sources.empty)
            return "";
        
        string projectDir = dirName(sources[0]);
        
        // Check for vite.config.ts (preferred for TypeScript projects)
        string tsConfig = buildPath(projectDir, "vite.config.ts");
        if (exists(tsConfig))
            return tsConfig;
        
        // Check for vite.config.mts (ESM TypeScript)
        string mtsConfig = buildPath(projectDir, "vite.config.mts");
        if (exists(mtsConfig))
            return mtsConfig;
        
        // Check for vite.config.js
        string jsConfig = buildPath(projectDir, "vite.config.js");
        if (exists(jsConfig))
            return jsConfig;
        
        // Check for vite.config.mjs (ESM)
        string mjsConfig = buildPath(projectDir, "vite.config.mjs");
        if (exists(mjsConfig))
            return mjsConfig;
        
        return "";
    }
    
    /// Detect framework from sources and dependencies
    private Framework detectFramework(const(string[]) sources)
    {
        // Check file extensions first
        if (sources.any!(s => s.endsWith(".vue")))
            return Framework.Vue;
        
        if (sources.any!(s => s.endsWith(".svelte")))
            return Framework.Svelte;
        
        if (sources.any!(s => s.endsWith(".jsx") || s.endsWith(".tsx")))
        {
            // Check for React/Preact in package.json if available
            string packageJson = findPackageJson(sources);
            if (!packageJson.empty && exists(packageJson))
            {
                try
                {
                    auto content = readText(packageJson);
                    if (content.indexOf("\"react\"") != -1)
                        return Framework.React;
                    if (content.indexOf("\"preact\"") != -1)
                        return Framework.Preact;
                }
                catch (Exception e)
                {
                    // Ignore
                }
            }
            
            // Default JSX/TSX to React
            return Framework.React;
        }
        
        return Framework.None;
    }
    
    /// Find package.json in source tree
    private string findPackageJson(const(string[]) sources)
    {
        if (sources.empty)
            return "";
        
        string dir = dirName(sources[0]);
        
        while (dir != "/" && dir.length > 1)
        {
            string packagePath = buildPath(dir, "package.json");
            if (exists(packagePath))
                return packagePath;
            
            dir = dirName(dir);
        }
        
        return "";
    }
    
    /// Generate Vite configuration
    private string generateViteConfig(
        string entry,
        string outputDir,
        string outputFile,
        TSConfig config,
        Framework framework,
        in Target target
    )
    {
        string pluginsSection = generatePlugins(framework);
        string buildSection = generateBuildSection(entry, outputDir, outputFile, config);
        string resolveSection = generateResolveSection(config);
        string esbuildSection = generateEsbuildSection(config);
        
        // Use TypeScript format for vite config
        return pluginsSection ~ `
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [` ~ getPluginsList(framework) ~ `],
  build: ` ~ buildSection ~ `,
  resolve: ` ~ resolveSection ~ `,
  esbuild: ` ~ esbuildSection ~ `
});
`;
    }
    
    /// Generate plugins import section
    private string generatePlugins(Framework framework)
    {
        final switch (framework)
        {
            case Framework.None:
                return "";
            case Framework.React:
                return "import react from '@vitejs/plugin-react';";
            case Framework.Vue:
                return "import vue from '@vitejs/plugin-vue';";
            case Framework.Svelte:
                return "import { svelte } from '@sveltejs/vite-plugin-svelte';";
            case Framework.Preact:
                return "import preact from '@preact/preset-vite';";
        }
    }
    
    /// Get plugins list for config
    private string getPluginsList(Framework framework)
    {
        final switch (framework)
        {
            case Framework.None:
                return "";
            case Framework.React:
                return "react()";
            case Framework.Vue:
                return "vue()";
            case Framework.Svelte:
                return "svelte()";
            case Framework.Preact:
                return "preact()";
        }
    }
    
    /// Generate build section
    private string generateBuildSection(
        string entry,
        string outputDir,
        string outputFile,
        TSConfig config
    )
    {
        string minifyOption = config.minify ? "'esbuild'" : "false";
        string sourcemapOption = config.sourceMap ? "true" : "false";
        
        // Library mode vs application mode
        string libSection = "";
        if (config.mode == TSBuildMode.Library)
        {
            string formatsList = generateLibraryFormats(config.moduleFormat);
            libSection = `
    lib: {
      entry: '` ~ absolutePath(entry) ~ `',
      name: '` ~ baseName(outputFile, ".js") ~ `',
      formats: [` ~ formatsList ~ `],
      fileName: (format) => '` ~ baseName(outputFile, ".js") ~ `.\${format}.js'
    },`;
        }
        
        string externalsSection = "";
        if (!config.external.empty)
        {
            externalsSection = `
    rollupOptions: {
      external: [` ~ config.external.map!(e => "'" ~ e ~ "'").join(", ") ~ `]
    },`;
        }
        
        return `{
    outDir: '` ~ absolutePath(outputDir) ~ `',
    emptyOutDir: true,
    minify: ` ~ minifyOption ~ `,
    sourcemap: ` ~ sourcemapOption ~ `,` ~ libSection ~ externalsSection ~ `
  }`;
    }
    
    /// Generate library formats
    private string generateLibraryFormats(TSModuleFormat format)
    {
        final switch (format)
        {
            case TSModuleFormat.ESM: return "'es'";
            case TSModuleFormat.ES2015: return "'es'";
            case TSModuleFormat.ES2020: return "'es'";
            case TSModuleFormat.ESNext: return "'es'";
            case TSModuleFormat.CommonJS: return "'cjs'";
            case TSModuleFormat.UMD: return "'umd'";
            case TSModuleFormat.AMD: return "'amd'";
            case TSModuleFormat.System: return "'system'";
            case TSModuleFormat.Node16: return "'cjs'";
            case TSModuleFormat.NodeNext: return "'cjs'";
        }
    }
    
    /// Generate resolve section
    private string generateResolveSection(TSConfig config)
    {
        return `{
    extensions: ['.ts', '.tsx', '.js', '.jsx', '.json', '.vue', '.svelte']
  }`;
    }
    
    /// Generate esbuild section for TypeScript compilation
    private string generateEsbuildSection(TSConfig config)
    {
        string tsTarget = targetToString(config.target);
        string jsxMode = jsxModeToString(config.jsx);
        
        return `{
    target: '` ~ tsTarget ~ `',
    jsx: '` ~ jsxMode ~ `',
    jsxFactory: '` ~ config.jsxFactory ~ `',
    jsxFragment: '` ~ config.jsxFragmentFactory ~ `',
    tsconfigRaw: {
      compilerOptions: {
        experimentalDecorators: ` ~ (config.experimentalDecorators ? "true" : "false") ~ `,
        emitDecoratorMetadata: ` ~ (config.emitDecoratorMetadata ? "true" : "false") ~ `,
        useDefineForClassFields: true
      }
    }
  }`;
    }
    
    private string targetToString(TSTarget target)
    {
        final switch (target)
        {
            case TSTarget.ES3: return "es3";
            case TSTarget.ES5: return "es5";
            case TSTarget.ES6: return "es6";
            case TSTarget.ES2015: return "es2015";
            case TSTarget.ES2016: return "es2016";
            case TSTarget.ES2017: return "es2017";
            case TSTarget.ES2018: return "es2018";
            case TSTarget.ES2019: return "es2019";
            case TSTarget.ES2020: return "es2020";
            case TSTarget.ES2021: return "es2021";
            case TSTarget.ES2022: return "es2022";
            case TSTarget.ES2023: return "es2023";
            case TSTarget.ESNext: return "esnext";
        }
    }
    
    private string jsxModeToString(TSXMode jsx)
    {
        final switch (jsx)
        {
            case TSXMode.Preserve: return "preserve";
            case TSXMode.React: return "transform";
            case TSXMode.ReactJSX: return "automatic";
            case TSXMode.ReactJSXDev: return "automatic";
            case TSXMode.ReactNative: return "preserve";
        }
    }
    
    /// Collect all outputs from directory
    private void collectOutputs(string outputDir, ref TSCompileResult result)
    {
        if (!exists(outputDir) || !isDir(outputDir))
            return;
        
        foreach (entry; dirEntries(outputDir, SpanMode.depth))
        {
            if (entry.isFile)
            {
                string ext = extension(entry.name);
                // Collect JS, CSS, source maps, and declaration files
                if (ext == ".js" || ext == ".mjs" || ext == ".cjs" || 
                    ext == ".css" || ext == ".map")
                {
                    result.outputs ~= entry.name;
                }
                else if (ext == ".ts" && entry.name.endsWith(".d.ts"))
                {
                    result.declarations ~= entry.name;
                    result.outputs ~= entry.name;
                }
            }
        }
    }
    
    bool isAvailable()
    {
        // Check if npx can find vite (works for both global and local installs)
        auto res = execute(["npx", "vite", "--version"]);
        return res.status == 0;
    }
    
    string name() const
    {
        return "vite";
    }
    
    string getVersion()
    {
        auto res = execute(["npx", "vite", "--version"]);
        if (res.status == 0)
        {
            // Vite version output is like "vite/5.0.0"
            return res.output.strip;
        }
        return "unknown";
    }
    
    bool supportsTypeCheck()
    {
        // Vite uses esbuild which doesn't type-check
        // Use tsc separately for type checking
        return false;
    }
}

/// Framework detection for Vite plugins
private enum Framework
{
    None,
    React,
    Vue,
    Svelte,
    Preact
}

