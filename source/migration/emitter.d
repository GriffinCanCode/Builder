module migration.emitter;

import std.array;
import std.algorithm;
import std.string;
import std.conv;
import migration.common;
import config.schema.schema : TargetType, TargetLanguage;

/// Emits Builderfile DSL from intermediate representation
/// Generates clean, idiomatic Builder configuration
struct BuilderfileEmitter
{
    private Appender!string output;
    private size_t indentLevel = 0;
    
    /// Generate Builderfile content from migration result
    string emit(const ref MigrationResult result)
    {
        output = appender!string();
        
        // Header comment
        writeLine("// Builderfile");
        writeLine("// Auto-generated by Builder migration tool");
        writeLine("// Review and adjust as needed");
        writeLine();
        
        // Global configuration if any
        if (result.globalConfig.length > 0)
        {
            emitGlobalConfig(result.globalConfig);
            writeLine();
        }
        
        // Emit each target
        foreach (i, target; result.targets)
        {
            if (i > 0)
                writeLine();
            emitTarget(target);
        }
        
        // Footer with warnings summary
        if (result.hasWarnings() || result.hasErrors())
        {
            writeLine();
            emitWarningsSummary(result);
        }
        
        return output.data;
    }
    
    private void emitGlobalConfig(const string[string] config)
    {
        writeLine("// Global configuration");
        foreach (key, value; config)
        {
            writeLine("// " ~ key ~ ": " ~ value);
        }
    }
    
    private void emitTarget(const ref MigrationTarget target)
    {
        // Target declaration
        writeLine(`target("` ~ target.name ~ `") {`);
        indentLevel++;
        
        // Type
        writeLine("type: " ~ targetTypeToString(target.type) ~ ";");
        
        // Language
        writeLine("language: " ~ languageToString(target.language) ~ ";");
        
        // Sources
        if (target.sources.length > 0)
        {
            emitStringArray("sources", target.sources);
        }
        
        // Dependencies
        if (target.dependencies.length > 0)
        {
            emitStringArray("deps", target.dependencies);
        }
        
        // Flags
        if (target.flags.length > 0)
        {
            emitStringArray("flags", target.flags);
        }
        
        // Includes
        if (target.includes.length > 0)
        {
            emitStringArray("includes", target.includes);
        }
        
        // Output
        if (target.output.length > 0)
        {
            writeLine(`output: "` ~ target.output ~ `";`);
        }
        
        // Environment variables
        if (target.env.length > 0)
        {
            emitEnvMap(target.env);
        }
        
        // Language-specific metadata as comments
        if (target.metadata.length > 0)
        {
            writeLine();
            writeLine("// Additional metadata:");
            foreach (key, value; target.metadata)
            {
                writeLine("// " ~ key ~ ": " ~ value);
            }
        }
        
        indentLevel--;
        writeLine("}");
    }
    
    private void emitStringArray(string name, const string[] values)
    {
        if (values.length == 1)
        {
            writeLine(name ~ `: ["` ~ values[0] ~ `"];`);
        }
        else
        {
            writeLine(name ~ ": [");
            indentLevel++;
            foreach (i, value; values)
            {
                string line = `"` ~ value ~ `"`;
                if (i < values.length - 1)
                    line ~= ",";
                writeLine(line);
            }
            indentLevel--;
            writeLine("];");
        }
    }
    
    private void emitEnvMap(const string[string] env)
    {
        writeLine("env: {");
        indentLevel++;
        
        auto keys = env.keys.array.sort().array;
        foreach (i, key; keys)
        {
            string line = `"` ~ key ~ `": "` ~ env[key] ~ `"`;
            if (i < keys.length - 1)
                line ~= ",";
            writeLine(line);
        }
        
        indentLevel--;
        writeLine("};");
    }
    
    private void emitWarningsSummary(const ref MigrationResult result)
    {
        writeLine("// Migration Summary");
        writeLine("// =================");
        
        if (result.hasErrors())
        {
            writeLine("// ERRORS:");
            foreach (error; result.errors())
            {
                writeLine("//   - " ~ error.message);
                if (error.context.length > 0)
                    writeLine("//     Context: " ~ error.context);
            }
        }
        
        if (result.hasWarnings())
        {
            writeLine("// WARNINGS:");
            foreach (warning; result.warnings)
            {
                if (warning.level == WarningLevel.Warning)
                {
                    writeLine("//   - " ~ warning.message);
                    if (warning.context.length > 0)
                        writeLine("//     Context: " ~ warning.context);
                }
            }
        }
        
        writeLine("//");
        writeLine("// Review the above issues and adjust the configuration as needed.");
    }
    
    private void writeLine(string text = "")
    {
        if (text.length > 0)
            output.put(indent() ~ text ~ "\n");
        else
            output.put("\n");
    }
    
    private string indent()
    {
        return "    ".replicate(indentLevel);
    }
    
    private string targetTypeToString(TargetType type) const
    {
        final switch (type)
        {
            case TargetType.Executable: return "executable";
            case TargetType.Library: return "library";
            case TargetType.Test: return "test";
            case TargetType.Custom: return "custom";
        }
    }
    
    private string languageToString(TargetLanguage lang) const
    {
        import std.uni : toLower;
        import std.conv : to;
        
        // Convert enum to string and lowercase
        string langStr = lang.to!string.toLower();
        
        // Handle special cases
        switch (lang)
        {
            case TargetLanguage.Cpp: return "cpp";
            case TargetLanguage.JavaScript: return "javascript";
            case TargetLanguage.TypeScript: return "typescript";
            case TargetLanguage.CSharp: return "csharp";
            case TargetLanguage.FSharp: return "fsharp";
            default: return langStr;
        }
    }
}

